# Spec Sheet: Total Available Aircraft + Mixed Fleet Optimization
**Target:** Replit Builder + Anthropic models (implementation-ready, explicit edge cases, minimal ambiguity)  
**Context:** PACAF demo workflow: ingest sanitized cargo list → compute aircraft required → produce load plans (ICODES-style outputs) and A2I-ready attachments. Mixed fleet must respect availability and “prefer one aircraft type” but allow mixed fleet when it’s more efficient/cheaper and necessary.

---

## 0) Definitions and Non-Negotiables

### Key terms
- **Aircraft Type**: A supported transport platform (e.g., C-17, C-130). The system must be able to add more types later without rewriting UI/DB.
- **Availability**: User-provided count of each aircraft type available for this plan.
- **Preference**: A preferred aircraft type (per SMSgt guidance: “choose one or the other” as the default logic). Mixed fleet may still be used when it improves efficiency/cost or the preferred type is insufficient.
- **Feasible plan**: A plan that (a) fits all cargo (or explicitly marks what is unallocated), (b) respects per-aircraft constraints, (c) does not exceed availability counts.
- **Optimization goal**: “Cheaper / more efficient” must be computed by an explicit cost model and shown to user. Never silently mix fleet without explaining why.

### Must-have UX truths
- User always sees: **(1) Required aircraft vs Available aircraft**, **(2) Any unallocated cargo**, **(3) Why mixed fleet was chosen**, **(4) Sensitivity controls** (e.g., preference weight, cost assumptions).
- If a plan cannot be satisfied due to insufficient availability, the app must produce:
  - **Best-effort allocation**
  - **Shortfall report** (what’s missing and by how much)
  - **Actionable suggestions** (increase C-17 by X, or allow C-130 mixing, etc.)

---

## 1) Data Model & Database Schema Updates

### 1.1 Supported Aircraft Registry (dynamic list)
Create a canonical registry table to drive UI and logic.

**Table: `aircraft_types`**
- `id` (uuid / string) — e.g., `"C17"`, `"C130"`
- `display_name` (string) — "C-17 Globemaster III"
- `active` (boolean) — for hiding deprecated types
- `capacity_model_version` (string) — e.g., `"v1"`
- `created_at`, `updated_at`

**Table: `aircraft_capacity_profiles`** (versioned, editable)
- `id`
- `aircraft_type_id` (FK)
- `version` (string) — `"v1"`
- `max_payload_lb` (number)
- `max_pallet_positions` (int, optional)
- `cargo_bay_dims` (json: length/width/height in)
- `notes` (text)
- `default_cost_params` (json; see cost model below)
- `created_at`, `updated_at`

> Goal: UI pulls `aircraft_types where active=true` and shows fields for each.

### 1.2 Availability per Scenario / Plan
Availability is not global; it is per plan/scenario upload session.

**Table: `plans`** (existing or create)
Add:
- `preferred_aircraft_type_id` (FK, nullable)
- `allow_mixed_fleet` (boolean, default true)
- `mixed_fleet_mode` (enum: `"PREFERRED_FIRST" | "OPTIMIZE_COST" | "MIN_AIRCRAFT" | "USER_LOCKED"`)
- `preference_strength` (number 0..1) — how strongly to favor preferred type in scoring
- `availability` (json) OR separate table below

**Recommended (normalized) table: `plan_aircraft_availability`**
- `id`
- `plan_id` (FK)
- `aircraft_type_id` (FK)
- `available_count` (int >= 0)
- `locked` (boolean, default false) — if user locks this type from being used
- `created_at`, `updated_at`

### 1.3 Output Artifacts
Store results to allow auditability.

**Table: `plan_solutions`**
- `id`
- `plan_id` (FK)
- `status` (enum: `"FEASIBLE" | "PARTIAL" | "INFEASIBLE"`)
- `aircraft_used` (json: { typeId: countUsed })
- `unallocated_cargo_ids` (json array)
- `metrics` (json: total cost, total aircraft, total flying hours estimates, etc.)
- `explanation` (text/json)
- `created_at`

---

## 2) Upload Page UX: “Available Aircraft” Required Section

### 2.1 Placement in UI
On Upload page (where cargo / UTC list is input):
Add a required section **before** user can run optimization:
**“Available Aircraft (Required)”**

### 2.2 Dynamic list behavior
- Fetch `aircraft_types(active=true)` from DB.
- For each aircraft type:
  - Show: `Display Name`, key capacity highlights (payload, pallet positions), and an input:
    - **Available Count** (integer stepper, min 0)
  - Optional toggles:
    - “Disable this aircraft type” (sets `locked=true`, forces used count = 0)
- Also show a **“Preferred aircraft type”** dropdown (values from active types).
- Also show **“Mixed fleet policy”** dropdown:
  1) Preferred-first (default)
  2) Optimize cost (uses explicit cost model)
  3) Min number of aircraft (ties broken by preference)
  4) User-locked (only uses explicitly selected types)
- Required validation:
  - At least one aircraft type must have `available_count > 0` unless user is only uploading for parsing (view-only mode).
  - If all are 0: block “Run Plan” with a clear error.

### 2.3 Inline guidance text (must show)
- “We will not exceed availability counts.”
- “If a plan is not feasible, we’ll show shortfalls and best-effort allocations.”
- “Preferred-first means we start with preferred type, and only mix when it improves efficiency/cost or preferred capacity is insufficient.”

---

## 3) Mixed Fleet Optimization Rules (per SMSgt + your business logic)

### 3.1 Hard constraints (must never violate)
- `used_count[type] <= available_count[type]`
- Cargo constraints (dimensions/weight/fit rules) per aircraft type
- Any cargo type restrictions (rolling stock vs palletized) per your existing rules
- If `locked=true`, then `used_count[type] = 0`

### 3.2 Preference + mixing behavior (must be explicit)
**Default behavior: “Preferred-first with efficient mixing”**
1. Try to allocate everything using preferred type only, up to its availability.
2. If cargo remains OR if a cheaper plan exists with mixing, consider mixed solutions.
3. Mixed solution is allowed if it is:
   - **Feasible**, and
   - **Cheaper or more efficient** than the preferred-only solution by a clear margin, OR
   - Required due to preferred type availability shortage.

**Example rule from user:** use 2 C-17 + 1 C-130 instead of 3 C-17 if 3 C-17 aren’t needed OR mixed is cheaper.

### 3.3 Define “cheaper / efficient” (must be implemented, not vague)
Implement a **configurable cost function** per aircraft type:
- `cost_per_flight` (fixed)
- `cost_per_hour`
- `estimated_hours_per_leg` (computed from distance / speed model)
- Optional: `cost_per_lb` (fallback if you don’t have route yet)

**Cost Model v1 (works even without route):**
- `estimated_cost = Σ (used_count[type] * default_cost_params[type].cost_per_sortie)`
- Add an optional adjustment for “utilization penalty”:
  - penalize very low load factor flights to encourage mixing if it reduces waste

**Cost Model v2 (with routes/distances):**
- `estimated_cost = Σ flights (cost_per_hour[type] * block_time + fixed_cost[type])`

UX requirement:
- Always show the cost breakdown and assumptions.
- Allow user to edit cost parameters in “Advanced” panel.

### 3.4 Optimization objective options (as per UI)
- **PREFERRED_FIRST**:
  - Primary: minimize deviation from preferred type (weighted)
  - Secondary: minimize cost
  - Tertiary: minimize number of aircraft
- **OPTIMIZE_COST**:
  - Primary: minimize cost
  - Secondary: minimize number of aircraft
  - Tertiary: prefer preferred type
- **MIN_AIRCRAFT**:
  - Primary: minimize total aircraft
  - Secondary: minimize cost
  - Tertiary: prefer preferred type
- **USER_LOCKED**:
  - Only use aircraft types not locked; if infeasible, return shortfall.

Implementation note: Use a single scoring function with weights:
`score = w_cost*cost + w_aircraft*totalAircraft + w_pref*prefPenalty`

`prefPenalty = Σ used_count[type != preferred] * preference_strength`

---

## 4) Planning Algorithm (Builder-Implementable, Deterministic)

### 4.1 Inputs
- Parsed cargo list (already typed)
- Availability counts per aircraft type
- Aircraft capacity profiles
- Mixed fleet policy + preference settings
- (Optional) route legs, if available

### 4.2 Outputs
- Aircraft assignment counts per type
- Per-aircraft load plans (your existing planner)
- Unallocated cargo list (if partial)
- Metrics + explanation

### 4.3 Algorithm approach (v1)
Because exact bin packing is hard, do this in a practical, demo-robust way:

1) **Preprocessing**
- Classify cargo: palletized vs rolling stock vs loose
- Compute “difficulty” score for each item:
  - oversized, heavy, rolling stock, etc.
- Sort cargo descending by difficulty/weight/volume.

2) **Generate candidate fleet mixes**
- Start with preferred-only: `usePreferred = min(requiredPreferred, availablePreferred)`
- Generate mixes by incrementally substituting aircraft types:
  - Example: replace 1 C-17 with N C-130 if capacity equivalence is plausible
- Limit candidates to avoid explosion (e.g., top 25 candidates)

3) **For each candidate fleet**
- Run your load planner to attempt allocation across aircraft instances.
- If feasible, compute score (cost + preference penalty + aircraft count).
- Keep best scoring solution.

4) **Return best solution**
- If none feasible:
  - return partial best-effort (max cargo allocated) + shortfall report.

### 4.4 Determinism requirement
- For same inputs, return same outputs.
- Use stable sorting and seeded randomness if any heuristics rely on random.

---

## 5) Parsing + Validation Changes

### 5.1 Upload validation now includes availability
Before “Run Plan,” validate:
- All `available_count` are integers >= 0
- At least one > 0 (unless view-only)
- Preferred type must be one of active types (or null)

### 5.2 Error messages (must be meaningful)
Examples:
- “Availability required: Set at least one aircraft count > 0.”
- “Preferred aircraft type is disabled/locked; choose another or unlock it.”
- “Infeasible: Cargo requires 3 C-17 but only 2 available. Shortfall: 1 C-17 (or enable C-130 mixing).”

---

## 6) UX: Results Presentation

### 6.1 Results header (must show)
- **Feasibility:** Feasible / Partial / Infeasible
- **Aircraft Used vs Available** table
- **Why this mix** (auto-generated explanation)

### 6.2 Explanation text (required)
If mixed fleet used, show:
- “Preferred-first attempted: X preferred aircraft used, remaining cargo required additional lift.”
- “Mixed fleet chosen because: (cost savings = $Y) OR (preferred availability insufficient).”
- Show at least one comparison:
  - Preferred-only vs chosen mix: aircraft count, estimated cost, estimated utilization.

### 6.3 Editing loop
User can tweak:
- Availability counts
- Mixed fleet policy
- Preference strength
…and rerun instantly.

---

## 7) Edge Cases (Must Handle)

1. **All availability zero** → block run with clear error.
2. **Preferred type availability zero** but selected → warning + auto-switch or block depending on policy.
3. **Cargo item cannot fit in any aircraft type** → mark as “UNSUPPORTED_ITEM” and keep unallocated, never crash.
4. **Locked type but needed** → infeasible message references lock.
5. **Mixed fleet disabled** → if preferred-only infeasible, return shortfall with suggestion.
6. **Ties in scoring** → deterministic tie-breakers:
   1) lower cost
   2) fewer aircraft
   3) more preferred aircraft used
7. **Partial allocations** → must show exact unallocated items and why (fit vs availability).
8. **Database migration**: existing plans without availability → default availability = unlimited? NO.
   - Require explicit availability going forward.
   - For old plans: set availability counts to 0 and show “needs availability” banner.

---

## 8) Implementation Tasks (Builder Checklist)

### Backend / DB
- [ ] Add `aircraft_types`, `aircraft_capacity_profiles`
- [ ] Add `plan_aircraft_availability`
- [ ] Add fields to `plans` for preference + policy
- [ ] Add `plan_solutions` for saved runs
- [ ] Write migrations + seed initial aircraft types (C-17, C-130) and capacity profiles

### API
- [ ] `GET /aircraft-types` (active)
- [ ] `GET /aircraft-capacity/:typeId` (latest profile)
- [ ] `POST /plans` create plan with availability + settings
- [ ] `POST /plans/:id/run` executes candidate mixes + planner
- [ ] `GET /plans/:id/solution/latest`

### Frontend
- [ ] Upload page: dynamic availability inputs + preferred dropdown + policy dropdown + preference slider
- [ ] Validation UI for missing/invalid availability
- [ ] Results UI: used vs available + explanation + comparison panel + rerun controls

### Planner Integration
- [ ] Candidate generation module
- [ ] Scoring function with configurable weights
- [ ] Best-effort partial solution logic
- [ ] Explanation generator (human-readable)

### Testing (minimum)
- [ ] Unit tests for validation (availability required, lock behavior)
- [ ] Deterministic outputs for same inputs
- [ ] Mixed fleet decision tests:
  - preferred-only feasible and cheaper → chooses preferred-only
  - preferred-only feasible but more expensive → chooses mixed
  - preferred availability insufficient → chooses mixed if allowed
  - mixed disabled + insufficient → infeasible with shortfall

---

## 9) Builder Notes (Anthropic/Replit Prompting Style)

- Always request code changes with:
  - exact file paths
  - exact schema migrations
  - typed interfaces
  - deterministic logic
  - clear error strings (user-facing)

- Do not “assume unlimited aircraft.” Availability is always enforced.

---

## 10) Acceptance Criteria (Done = Done)

A run is accepted when:
1. Upload page requires availability and saves it.
2. Planner never exceeds availability counts.
3. Mixed fleet obeys selected policy and preference strength.
4. Results page clearly shows used vs available, cost/efficiency rationale, and shortfalls if any.
5. Rerun after changing availability/policy works without state desync.
6. Tests cover the edge cases listed above.

---
